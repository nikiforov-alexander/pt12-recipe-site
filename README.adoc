= Techdegree project 10 : Recipes
:experimental:
:source-highlighter: coderay
:toc:
:toclevels: 5
:toc-placement: preamble
:sectnums:
:main_package: link:./src/main/java/com/techdegree/
:test_package: link:./src/test/java/com/techdegree
:ItemValidator: {main_package}validator/ItemValidator.java[ItemValidator]
:PasswordMatchesValidator: {main_package}validator/PasswordMatchesValidator.java[PasswordMatchesValidator]
:PasswordMatches: {main_package}validator/PasswordMatches.java[PasswordMatches]
:ValidItem: {main_package}validator/ValidItem.java[ValidItem]
:CustomUserDetailsService: {main_package}service/CustomUserDetailsService.java[CustomUserDetailsService]
:IngredientService: {main_package}service/IngredientService.java[IngredientService]
:StepService: {main_package}service/StepService.java[StepService]
:ItemService: {main_package}service/ItemService.java[ItemService]
:RecipeService: {main_package}service/RecipeService.java[RecipeService]
:RecipeServiceImpl: {main_package}service/RecipeServiceImpl.java[RecipeServiceImpl]
:IngredientServiceImpl: {main_package}service/IngredientServiceImpl.java[IngredientServiceImpl]
:ItemServiceImpl: {main_package}service/ItemServiceImpl.java[ItemServiceImpl]
:StepServiceImpl: {main_package}service/StepServiceImpl.java[StepServiceImpl]
:DataLoader: {main_package}DataLoader.java[DataLoader]
:Application: {main_package}Application.java[Application]
:BaseEntity: {main_package}model/BaseEntity.java[BaseEntity]
:User: {main_package}model/User.java[User]
:UserDto: {main_package}dto/UserDto.java[UserDto]
:UserAlreadyExistsException: {main_package}exception/UserAlreadyExistsException.java[UserAlreadyExistsException]
:CustomAccessDeniedException: {main_package}exception/CustomAccessDeniedException.java[CustomAccessDeniedException]
:RoleClass: {main_package}model/Role.java[Role]
:RecipeCategory: {main_package}model/RecipeCategory.java[RecipeCategory]
:Ingredient: {main_package}model/Ingredient.java[Ingredient]
:Item: {main_package}model/Item.java[Item]
:Step: {main_package}model/Step.java[Step]
:Recipe: {main_package}model/Recipe.java[Recipe]
:RecipeDaoImpl: {main_package}dao/RecipeDaoImpl.java[RecipeDaoImpl]
:RoleDao: {main_package}dao/RoleDao.java[RoleDao]
:UserDao: {main_package}dao/UserDao.java[UserDao]
:StepDao: {main_package}dao/StepDao.java[StepDao]
:ItemDao: {main_package}dao/ItemDao.java[ItemDao]
:IngredientDao: {main_package}dao/IngredientDao.java[IngredientDao]
:RecipeDao: {main_package}dao/RecipeDao.java[RecipeDao]
:FavoriteRecipesDao: {main_package}dao/FavoriteRecipesDao.java[FavoriteRecipesDao]
:FlashMessage: {main_package}web/FlashMessage.java[FlashMessage]
:LoginController: {main_package}web/controller/LoginController.java[LoginController]
:RecipeController: {main_package}web/controller/RecipeController.java[RecipeController]
:UserController: {main_package}web/controller/UserController.java[UserController]
:IndexRedirectController: {main_package}web/controller/IndexRedirectController.java[IndexRedirectController]
:WebConstants: {main_package}web/WebConstants.java[WebConstants]
:RecipeEventHandler: {main_package}handler/RecipeEventHandler.java[RecipeEventHandler]
:RestConfig: {main_package}config/RestConfig.java[RestConfig]
:AppConfig: {main_package}config/AppConfig.java[AppConfig]
:SecurityConfig: {main_package}config/SecurityConfig.java[SecurityConfig]
:TemplateConfig: {main_package}config/TemplateConfig.java[TemplateConfig]
:RecipeCategoryTest: {test_package}/model/RecipeCategoryTest.java[RecipeCategoryTest]
:RecipeDaoTest: {test_package}/dao/RecipeDaoTest.java[RecipeDaoTest]
:RecipeServiceTest: {test_package}/service/RecipeServiceTest.java[RecipeServiceTest]
:UserServiceTest: {test_package}/service/UserServiceTest.java[UserServiceTest]
:UserDtoTest: {test_package}/dto/UserDtoTest.java[UserDtoTest]
:IndexRedirectControllerTest: {test_package}/web/controller/IndexRedirectControllerTest.java[IndexRedirectControllerTest]
:RecipeControllerItTest: {test_package}/web/controller/RecipeControllerItTest.java[RecipeControllerItTest]
:RecipeControllerTest: {test_package}/web/controller/RecipeControllerTest.java[RecipeControllerTest]
:LoginControllerItTest: {test_package}/web/controller/LoginControllerItTest.java[LoginControllerItTest]
:LoginControllerTest: {test_package}/web/controller/LoginControllerTest.java[LoginControllerTest]
:UserControllerTest: {test_package}/web/controller/UserControllerTest.java[UserControllerTest]
:RecipeRestIntegrationTest: {test_package}/RecipeRestIntegrationTest.java[RecipeRestIntegrationTest]
:IngredientRestIntegrationTest: {test_package}/IngredientRestIntegrationTest.java[IngredientRestIntegrationTest]
:StepRestIntegrationTest: {test_package}/StepRestIntegrationTest.java[StepRestIntegrationTest]
:ItemRestIntegrationTest: {test_package}/ItemRestIntegrationTest.java[ItemRestIntegrationTest]
:build_gradle: link:./build.gradle[build.gradle]
:main_resources: link:./src/main/resources/
:templates: {main_resources}templates
:application_properties: {main_resources}application.properties[application.properties]
:signup_html: {templates}/signup.html[signup.html]
:edit_html: {templates}/edit.html[edit.html]
:login_html: {templates}/login.html[login.html]
:index_html: {templates}/index.html[index.html]
:detail_html: {templates}/detail.html[detail.html]
:layout_html: {templates}/layout.html[layout.html]
:profile_html: {templates}/profile.html[profile.html]
:app_js: {main_resources}/static/assets/js/app.js[app.js]
:coverage_report_tar_gz: link:./misc/coverage-report.tar.gz[coverage-report.tar.gz]
:userDtoBaeldungLink: http://www.baeldung.com/registration-with-spring-mvc-and-spring-security
:passwordRegexLink: http://regexlib.com/REDetails.aspx?regexp_id=31
:jqueryPasswordCheckerLink: https://www.formget.com/password-strength-checker-in-jquery/

toc::[]

[[eclipse]]
== Eclipse Installation Instructions

Under Construction.

// Links

== Tasks


=== Task 1 - Overview: Model/Dao/Service, Unit Tests

Create model classes, DAO interfaces, services,
and add unit tests to components.
Determine test coverage using a code coverage tool
and ensure your tests cover of at least 60% of your code.

---

[[task-1-model]]
==== Model

Model classes created are:

* {Ingredient}
* {Item}
* {Recipe}
* {RoleClass}
* {Step}
* {User}

Some of them inherit {BaseEntity}, which is the `@MappedSuperClass`
that has `@Id id` and `@Version version` fields, that are
repeated in child classes.

{RecipeCategory} enum is used in {Recipe} class as `@Enumerated` field.

[[task-1-dao]]
==== DAO

DAO interfaces are created as Spring-Data `CrudRepository`-ies:

.Recipe related DAOs:
** {RecipeDao}
** {FavoriteRecipesDao}
** {RecipeDaoImpl}

.User related DAOs:
** {RoleDao}
** {UserDao}

.Other DAOs
* {IngredientDao}
* {ItemDao}
* {StepDao}

All {User} related DAOs are not exposed to REST API.

{FavoriteRecipesDao} is interface that allows us to add custom
methods to Spring-Data DAOs. And {RecipeDaoImpl} is the class that
implements {FavoriteRecipesDao} and defines manually defined
methods (For now only method listing favorite recipes for user).

[[task-1-service]]
==== Service

Service layer implementations do not have anything in particular,
except repeating commands at DAO layer:

* {CustomUserDetailsService}
* {IngredientService}
* {IngredientServiceImpl}
* {ItemService}
* {ItemServiceImpl}
* {RecipeService}
* {RecipeServiceImpl}
* {StepService}
* {StepServiceImpl}

Most of them repeat commands at DAO layer with few exceptions:

{RecipeDao} has significantly different `save` method that takes
into consideration that recipe has favorites and owner, see
related <<favorites, Favorites>> and <<recipe_owner, Recipe Owner>>
sections for more:

{CustomUserDetailsService} `implements UserDetailsService` and is very
common service that has `loadUserByUsername` method

[[task-1-coverage]]
==== Coverage

Coverage report is in gzipped file called
{coverage_report_tar_gz}

It was generated after I created configuration in
Intellijidea with
all tests and after running it I saved coverage and
gzipped it, because it has too many files. Later
I will try to create task in Gradle, but for now
that is best I can do.

=== Task 2 - Recipes Index Page
Using the supplied files, create the template for the recipe list page.
Use the following requirements list to ensure all functionality
is included in the recipe list page.

Recipes:

. <<favorites, Favorites>>
+
Displays a list of recipes by name and indicates
with a heart icon whether a user has favorited the recipe

. <<filter_by_category, Filter By Category>>
+
Allows the user to filter the list by the selected category

. <<add-new-recipe, Add New Recipe>>
+
Allows the user to add a new recipe

. <<user_account_page, User Account Page>>
+
A user must have an account

. <<edit_and_delete_recipe, Edit and Delete Recipe>>
+
Allows the user to edit or delete a recipe

. <<recipe_owner, Recipe Owner>>
+
A user must own the recipe

---

[[favorites]]
==== Favorites

Displays a list of recipes by name and indicates
with a heart icon whether a user has favorited the recipe

---

Recipes are displayed at the main page with the address

```
http://localhost:8080/
http://localhost:8080/recipes
http://localhost:8080/recipes/
```

{IndexRedirectController} takes care of redirecting from
both "/" and "/recipes" pages to "/recipes/" that is mapped
in {RecipeController}. There is probably a better way. But
I'll leave it for now as is. The functionality is tested in
{IndexRedirectControllerTest}

In order to show whether recipe is favorite for user we
generate `List<Recipe> favoriteRecipesWithNullsForNonFavorites`
that has exactly the same
size as all recipes printed, but on the places where
recipe is favorite for user, it contains recipe, and
elsewhere is `null`. This list is passed along with all recipes
to `Model`.

The list to be passed is generated in a
[java]`RecipeController.generateFavoritesWithNullsForNonFavoritesList`
method. And because of that is tested separately in
[java]`@Test favoritesWithNonNullsListIsGeneratedCorrectly` in
{RecipeControllerTest}

Simple list with favorite recipes for users is generated at DAO
level at customized {RecipeDaoImpl} using simple SQL query. It was
rather problematic for me to write Spring Query in annotation to
some method in {RecipeDao}, that is why I decided to make custom
implementation for now.

The function returning favorite recipes at DAO level is tested in
{RecipeDaoTest} in `findAllFavoritesReturnsOneFavoriteRecipeWithDataLoader`
test.

In the REST API for now it is impossible to get favorite recipes

This can be done in many different ways, but I decided to leave it so.

[[filter_by_category]]
==== Filter By Category

Allows the user to filter the list by the selected category

---

[[filter_by_category_usage]]
===== Usage

In the {DataLoader} for now 5 recipes are added, one for each category.
They are all have "tags" that can be clicked and user will be redirected
to the index page sorted by selected category tag:

```
/recipes/?category=name
```

There is also JavaScript function in {app_js} file
that is executed when `<select>`
element is changed. It redirects to index page filtered
by category.

[[filter_by_category_impl_details]]
===== Implementation Details

Implementation starts on model layer in {RecipeCategory}
`enum`. I introduced new methods `getRecipeCategoryWithHtmlName`
that returns `RecipeCategory.NONE` or `RecipeCategory`
found by member `htmlName`.

This method is tested in {RecipeCategoryTest}
`allRecipeCategoriesCanBeFoundByName`.

At *DAO* level I introduced Spring Query method called
`findByRecipeCategory` that comes from Spring and returns
`List<Recipe>` with `RecipeCategory` passed in argument.

This is tested in {RecipeDaoTest}
`listOfRecipesReturnedWhenFindByRecipeCategoryIsCalled`.

At *Service* layer I introduced in {RecipeService} and
implemented in {RecipeServiceImpl} `findByRecipeCategoryName`

I didn't test that because it directly returns result of
`RecipeDao.findByRecipeCategory` with argument as a result
of `RecipeCategory.getRecipeCategoryWithHtmlName`. It may be
not a good idea to put this functionality on *Service* layer, but
I decided to leave it here.

At *Controller* layer in {RecipeController}
`filterByCategory` method was introduced, that is passing
to `Model.attribute` "recipes" not all recipes, but the
ones `recipeService.findByCategoryName` returns. Argument
is query parameter. It comes from JavaScript or from tag anchor,
see <<filter_by_category_usage, Usage>>.

Also here is "selectedCategory" attribute is added to `Model`
because we want to display selected option on the redirected
page.

This functionality is tested in {RecipeControllerTest}
`recipesCanBeListedByCategoryOnIndexPage` test.


[[add-new-recipe]]
==== Add New Recipe

Allows the user to add a new recipe

---

New recipe can be added from the home page
by pressing "Add Recipe" button.

After pressing that button page `/recipes/add-new` is generated.
Template {edit_html} is used for both `/recipes/add-new` and
`/recipes/edit/id`, with the difference that `new Recipe` object
is passed to `Model` when `/recipes/add-new` is generated, and
`Recipe` from database is passed to `Model` when `/recipes/edit/id`
page is generated.

I made a try to re-use some code by creating
`addAttributesToModelForBothEditAndAddNewPages`. Don't know
whether that was a good idea or not, but I tried.

I also tried to use the same method `saveRecipe` for
both adding new recipe POST request and updating
already existing recipe.


[[user_account_page]]
==== User Account Page

A user must have an account

---

User has an account page at the address

```
/profile
```

In order to get to this page, being logged on, user
has to click on his name in the top left corner on
`<nav>` element

This is implemented in {UserController} class, and is
tested in {UserControllerTest} class.

The template rendering this page is called {profile_html}.

On this page all user's favorite recipes are displayed.
May be later I will include also owned recipes. For now
I'll leave that as TODO.

[[edit_and_delete_recipe]]
==== Edit and Delete Recipe

Allows the user to edit or delete a recipe

---

For now user can delete recipe, without any problems.
No restrictions on that. About edit, the same policy
applies, see section about saving recipe above.

[[recipe_owner]]
==== Recipe Owner

A user must own the recipe

---

When we save recipe we set recipe's owner.
The responsible field for this relationship is
`@ManyToOne Recipe.owner` on the {Recipe} side,
and `@OneToMany User.ownedRecipes` on the {User} side.
The relationship is determined by foreign_key
`owner_id` in the recipes table.

When Recipe is updated, we get the owner from database.

All functionality was moved by me to
service layer in `RecipeService.save` method, that
takes care not only about the owner of recipe, but
also sets favorite recipes from database, and
set `Recipe.ingredients[i].items` because with the
POST request we set only item id-s.

Related tests can be found in Mock-test in
{RecipeServiceTest} class:

* `savingNewRecipeSetsOwner`
* `updatingRecipeDoesNotChangeOwner`

Integration tests in {RecipeControllerItTest} are checking
recipe owner consistency as well. See tests:

* `updatingRecipeWithAllValidFieldsWorks`
* `savingNewRecipeWithAllValidFieldsWorks`
* `deletingRecipeShouldBePossible`

=== Task 3 : Recipe Details Page

Using the supplied files, create the template for the recipe detail page.
Use the following requirements list to ensure all functionality
is included in the recipe detail page.

.Recipe Detail
. <<recipe_details_owner, Only Owner And Admin Can Edit And/Or Update Recipe>>
+
Allows a user to add a recipe, or edit the recipe if they are the owner

. <<provide_recipe_details, User Can Add Recipe details>>
+
Allows a user to provide a recipe name, description, category 
(from a list of values), prep time, and cook time

. <<ingredients_list_edit_recipe, User Can Add Ingredients>>
+
Allows a user to provide a list of ingredients. Each ingredient includes an item, condition, and quantity

. <<steps_list_edit_recipe, User Can Add Steps>>
+
Allows a user to provide a list of steps. Each step includes a description

. <<recipe_favorite_detail_page, User Can Add/Remove Recipe to/from Favorites>>
+
Any user can add the recipe to their favorites

---

[[recipe_details_owner]]
==== Only Owner And Admin Can Edit And/Or Update recipe

Allows a user to add a recipe, or edit the recipe if they are the owner

---

In order to introduce security here, additional method that 
`throws AccessDeniedException` was introduced in *Service* layer,
in {RecipeServiceImpl}:

```
checkIfUserCanEditRecipe

```

This method is used in `saveRecipe` processing POST request
to add/update `Recipe` and in `editRecipePage` that is
responsible to GET request that is sent when user wants
to see "edit" recipe page.

The sole purpose of this method as it follows from name
is to check is user is admin or owner. If he is not, than
exception is thrown.

The functionality tested on all levels:

* {RecipeServiceTest}

** `permissionDeniedIsThrownWhenUserIsNonOwnerNonAdmin`

* {RecipeControllerTest}

** `nonOwnerNonAdminCannotAccessEditRecipePage`

** `nonOwnerNonAdminCannotUpdateRecipe`

In {RecipeControllerItTest} only positive test is done, i.e. for now
all the updates are made with logged owner user.

[[provide_recipe_details]]
==== User Can Add Recipe Details

Allows a user to provide a recipe name, description, category 
(from a list of values), prep time, and cook time
Under construction.

---

All fields that were provided in template files can be filled
by user. I used `@NotNull` and `@NotEmpty` annotation for all
of them for simplicity.

When one will press 'Add Recipe' button at Home Page
and will be redirect to page with adding new recipe.

In order to see that fields are all required, one can press
submit button, and see how all of them turn red.

I tested the validation errors only in
"Integration" {RecipeControllerItTest}. The problem emerged,
because Thymeleaf did not set `Recipe` for each `recipe.ingredients`
and `recipe.steps`. That is why we had to remove `@Valid` as 
annotation from arguments of `saveRecipe` controller method, 
and before validation, set missing relationships
(see {RecipeController} `saveRecipe` for more).

It is probably possible to test the functionality in "mock"
{RecipeControllerTest}, but I need to somehow to `@Mock` 
`Validator` manually, and I yet don't know how to do it.

The Validation errors are tested in {RecipeControllerItTest} in
following test:

* `updatingRecipeWithAllNullInvalidFieldsShouldGiveThatNumberOfErrors`
* `addingRecipeWithAllEmptyInvalidFieldsShouldGiveThatNumberOfErrors`

[[ingredients_list_edit_recipe]]
==== User Can Add Ingredients

Under construction.

[[steps_list_edit_recipe]]
==== User Can Add Steps

Under construction.

[[recipe_favorite_detail_page]]
==== User Can Add/Remove Recipe to/from Favorites

Under construction.

=== Task 4 : Search Features

The recipe list page should have a search feature.
A user can enter a search term and the recipe
list will display results that have the search
phrase in the description.

---

Under construction.

=== Task 5 : Security

Enable user authentication with Spring Security.
Use the supplied files to create templates
for login page, registration page, and profile page.
You must build the registration component,
as it does not come with Spring Security.
Create necessary controllers,
services, and DAO to add a new user.
Make sure to include validation
so that a user may not use a username
that already exists.
Check out links in external resources if you get stuck.

---

[[task-5-security-config]]
==== Security Configuration class

User authentication is enabled in {SecurityConfig} class.

It enables `@PreAuthorize` and other annotations, as well as
password encoder.

In `configure(WebSecurity web)` method we setup ignoring everything that is in
`src/main/resources/static/assets`, i.e. all images, CSS and
JavaScript.

In `configure(HttpSecurity http)` we permit user
before logging in, access only `SIGN_UP_PAGE` and
`LOGIN_PAGE`.

`loginSuccessHandler` redirects user to `RECIPES_HOME_PAGE`,
whereas `loginFailureHandler` creates flash message that
attaches {FlashMessage} with `FAILURE` status.

==== LoginController

{LoginController} class is created in order to set up

* `LOGIN_PAGE` in `loginForm` method
* `SIGN_UP_PAGE` in `signUpPage` method
* `SIGN_UP_PAGE` POST request in `registerNewUser` method.

I don't exactly know how `loginForm` works. But
I know that it sets "flash" from session if user types
wrong password. If however, user register valid user
on `SIGN_UP_PAGE`, then he'll be redirected to this
page with successful flash to log in.

`SIGN_UP_PAGE` simply loads new {UserDto} object into
`Model`, and if user made mistakes when creating new
user, then he is redirected back with all user
parameters except `password` and `matchingPassword`

`registerNewUser` processes POST request of creating
new user.

==== UserDto And Password

Idea of {UserDto} came from {userDtoBaeldungLink}[here].
It is first of all needed because we set password
indirectly and cannot use validation annotation
on `User.password` field directly. Also nice thing about
this approach that we created our own {PasswordMatches}
annotation that uses {PasswordMatchesValidator}
and checks if passwords match. Whereas we cannot simply
introduce new `matchingPassword` field in {User} class.

One has to note here on `userDto.password` field regex
matcher is used taken from {passwordRegexLink}[here].

The regex is tested separately in the {UserDtoTest} class.

==== JavaScript In Registration

One has also note here, that in order to ensure more
security and not sending password back and forth, i.e.
to increase user experience I've added in {app_js} file
JavaScript Jquery function checking whether passwords in
`SIGN_UP_PAGE` match, and whether they are strong or not.
The most of the code was taken from
{jqueryPasswordCheckerLink}[here].

The button "sign-up" sending POST request will appear only
if both password match and are "strong".

So we won't see backend check unless we actually disable
JavaScript. But I decided to leave them both hanging.

==== User Registration On Service Layer

"Check whether the user exists with such username" is done
on service layer in `userService.registerNewUser` method.

It throws {UserAlreadyExistsException} that unfortunately
does not work properly with `@ExceptionHandler` that is
why it is explicitly caught in {LoginController}
`registerNewUser` method

[[task-5-tests]]
==== Tests

The tests checking most of the user registration can
be found in following classes:

* {LoginControllerTest}
* {LoginControllerItTest}
* {UserServiceTest}

=== Task 6 : REST API

Create REST endpoints for CRUD operations.

---

==== Configuration

REST API is build with HATEOAS and HAL browser, from the
following dependencies in {build_gradle}:

```
    compile 'org.springframework.boot:spring-boot-starter-data-rest'
    compile 'org.springframework.data:spring-data-rest-hal-browser'
```

In {application_properties} file `spring.data.rest.base-path` is defined, so
that we know upon which address to find out REST API.

In the `@Configuration` {RestConfig} class we add @Validator for
all entities as `ValidatingRepositoryEventListener`. Apparently that
is because REST is built from DAO, and without having *Service*
layer helping out with the stuff, we are using *Events* and
*Listeners*.

`Validator` itself is defined from `LocalValidatorFactoryBean` in
{AppConfig} class.

One more important class that interacts with REST is
{RecipeEventHandler}. For now `@HandleBeforeCreate` event is
defined there, with which we set-up owner of the `Recipe`
before saving, and `@HandleBeforeSave` as well, by checking that
only owner of `Recipe` or admin can update `Recipe`.

==== End Points

Below is the list of links REST generates for us to use:

```
/api/v1/recipes : GET, PUT, POST, DELETE
/api/v1/ingredients : GET, PUT, POST, DELETE
/api/v1/steps : GET, PUT, POST, DELETE
/api/v1/items : GET, PUT, POST, DELETE
```

URI-s are defined automatically, but I've also specified
them in {WebConstants} class, so that we can use them
type-safe in tests.

In order to see specific object one has to add `id` at the
end.

==== Life Cycle of REST requests

It is impossible to create `Recipe` with `Ingredient`-s and `Step`-s
in one request unfortunately.
And I don't know how to do it. In order to create new Recipe
one has to do the following:

* make POST request to create new `Recipe` without links:
+
```
{
    "id" : null,
    "version" : null,
    "name" : "test name",
    "description" : "test description",
    "recipeCategory" : "BREAKFAST",
    "photoUrl" : "test photo url",
    "preparationTime" : "test prep time",
    "cookTime" : "test cook time",
    "ingredients" : [],
    "steps" : []
}
```
* make POST request to create new `Ingredient` with `Recipe`
and `Item` link:
+
```
{
   "id" : "null",
   "version" : "null",
   "item" : "http://localhost:8080/api/v1/items/1",
   "condition" : "condition",
   "quantity" : "quantity",
   "recipe" : "http://localhost:8080/api/v1/recipes/1"
}
```
+
NOTE: `Item` can be created without links easily via POST with: `{ "name" : "item" }`
+
* make POST request to create new `Step` with `Recipe` link:
+
```
{
   "id" : "null",
   "version" : "null",
   "description" : "description",
   "recipe" : "http://localhost:8080/api/v1/recipes/1"
}
```

`PUT` requests can be done in the same manner. So I omit this
section description here

`DELETE` requests are done with empty body but with `id` of the entity
to be deleted.

==== Security

===== Recipes

`Recipe` can be updated only by owner of `Recipe` or admin user.
Whether user is admin or owner is checked in {RecipeEventHandler} class in
`checkIfOwnerOrAdminIsEditing` method. Upon authentication error,
{CustomAccessDeniedException} is thrown that is just like usual
`AccessDeniedException` provided by Spring, but this custom 
can be tested. When we throw `AccessDeniedException` then
in tests `NestedServletException` is thrown, that complicates
test checks.

`Recipe` deletion is managed by `@PreAuthorize` Spring Security
Expression, that is enabled in {SecurityConfig} class. The idea
here is naturally same: only owner of `Recipe` or admin user
can delete Recipe.

===== Ingredients and Steps

For both of these entities `save` and `delete` methods are 
introduced with the same Spring Security `@PreAuthorize` 
expression that permits actions only to `ingredient.recipe.owner` or 
admin.

For `Step` `delete` method is not introduced, and for `Ingredient` 
method `delete` is not fully tested. `save` method is tested for
both `Ingredient` and `Step`

==== Tests

Mostly REST API is tested with following integration tests:

* {RecipeRestIntegrationTest}
* {StepRestIntegrationTest}
* {IngredientRestIntegrationTest}
* {ItemRestIntegrationTest}









